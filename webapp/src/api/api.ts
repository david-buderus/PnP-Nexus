/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AdditiveUpgradeEffect
 */
export interface AdditiveUpgradeEffect {
    /**
     * 
     * @type {string}
     * @memberof AdditiveUpgradeEffect
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof AdditiveUpgradeEffect
     */
    'upgradeManipulator': AdditiveUpgradeEffectUpgradeManipulatorEnum;
    /**
     * 
     * @type {number}
     * @memberof AdditiveUpgradeEffect
     */
    'value'?: number;
}

export const AdditiveUpgradeEffectUpgradeManipulatorEnum = {
    None: 'NONE',
    Slots: 'SLOTS',
    Damage: 'DAMAGE',
    Hit: 'HIT',
    Initiative: 'INITIATIVE',
    Armor: 'ARMOR',
    Weight: 'WEIGHT'
} as const;

export type AdditiveUpgradeEffectUpgradeManipulatorEnum = typeof AdditiveUpgradeEffectUpgradeManipulatorEnum[keyof typeof AdditiveUpgradeEffectUpgradeManipulatorEnum];

/**
 * 
 * @export
 * @interface AdditiveUpgradeEffectAllOf
 */
export interface AdditiveUpgradeEffectAllOf {
    /**
     * 
     * @type {number}
     * @memberof AdditiveUpgradeEffectAllOf
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface Armor
 */
export interface Armor {
    /**
     * 
     * @type {string}
     * @memberof Armor
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Armor
     */
    'effect': string;
    /**
     * 
     * @type {string}
     * @memberof Armor
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Armor
     */
    'maximumStackSize': number;
    /**
     * 
     * @type {number}
     * @memberof Armor
     */
    'minimumStackSize': number;
    /**
     * 
     * @type {string}
     * @memberof Armor
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Armor
     */
    'note': string;
    /**
     * 
     * @type {ERarity}
     * @memberof Armor
     */
    'rarity': ERarity;
    /**
     * 
     * @type {string}
     * @memberof Armor
     */
    'requirement': string;
    /**
     * 
     * @type {ItemType}
     * @memberof Armor
     */
    'subtype': ItemType;
    /**
     * 
     * @type {number}
     * @memberof Armor
     */
    'tier': number;
    /**
     * 
     * @type {ItemType}
     * @memberof Armor
     */
    'type': ItemType;
    /**
     * 
     * @type {number}
     * @memberof Armor
     */
    'vendorPrice': number;
    /**
     * 
     * @type {number}
     * @memberof Armor
     */
    'armor': number;
    /**
     * 
     * @type {Material}
     * @memberof Armor
     */
    'material': Material;
    /**
     * 
     * @type {number}
     * @memberof Armor
     */
    'upgradeSlots': number;
    /**
     * 
     * @type {number}
     * @memberof Armor
     */
    'weight': number;
}


/**
 * 
 * @export
 * @interface ArmorAllOf
 */
export interface ArmorAllOf {
    /**
     * 
     * @type {number}
     * @memberof ArmorAllOf
     */
    'armor'?: number;
    /**
     * 
     * @type {Material}
     * @memberof ArmorAllOf
     */
    'material'?: Material;
    /**
     * 
     * @type {number}
     * @memberof ArmorAllOf
     */
    'upgradeSlots'?: number;
    /**
     * 
     * @type {number}
     * @memberof ArmorAllOf
     */
    'weight'?: number;
}
/**
 * 
 * @export
 * @interface CharacterResourceRecipeEntry
 */
export interface CharacterResourceRecipeEntry {
    /**
     * 
     * @type {number}
     * @memberof CharacterResourceRecipeEntry
     */
    'amountOfRequiredUnits'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterResourceRecipeEntry
     */
    'resource'?: CharacterResourceRecipeEntryResourceEnum;
}

export const CharacterResourceRecipeEntryResourceEnum = {
    Health: 'HEALTH',
    Mana: 'MANA',
    MentalHealth: 'MENTAL_HEALTH'
} as const;

export type CharacterResourceRecipeEntryResourceEnum = typeof CharacterResourceRecipeEntryResourceEnum[keyof typeof CharacterResourceRecipeEntryResourceEnum];

/**
 * 
 * @export
 * @interface CharacterResourceRecipeEntryAllOf
 */
export interface CharacterResourceRecipeEntryAllOf {
    /**
     * 
     * @type {number}
     * @memberof CharacterResourceRecipeEntryAllOf
     */
    'amountOfRequiredUnits'?: number;
    /**
     * 
     * @type {string}
     * @memberof CharacterResourceRecipeEntryAllOf
     */
    'resource'?: CharacterResourceRecipeEntryAllOfResourceEnum;
}

export const CharacterResourceRecipeEntryAllOfResourceEnum = {
    Health: 'HEALTH',
    Mana: 'MANA',
    MentalHealth: 'MENTAL_HEALTH'
} as const;

export type CharacterResourceRecipeEntryAllOfResourceEnum = typeof CharacterResourceRecipeEntryAllOfResourceEnum[keyof typeof CharacterResourceRecipeEntryAllOfResourceEnum];

/**
 * 
 * @export
 * @interface CraftingRecipe
 */
export interface CraftingRecipe {
    /**
     * 
     * @type {string}
     * @memberof CraftingRecipe
     */
    'id'?: string;
    /**
     * 
     * @type {Array<CraftingRecipeMaterialsInner>}
     * @memberof CraftingRecipe
     */
    'materials': Array<CraftingRecipeMaterialsInner>;
    /**
     * 
     * @type {string}
     * @memberof CraftingRecipe
     */
    'otherCircumstances': string;
    /**
     * 
     * @type {ItemRecipeEntry}
     * @memberof CraftingRecipe
     */
    'product': ItemRecipeEntry;
    /**
     * 
     * @type {string}
     * @memberof CraftingRecipe
     */
    'profession': string;
    /**
     * 
     * @type {string}
     * @memberof CraftingRecipe
     */
    'requirement': string;
    /**
     * 
     * @type {ItemRecipeEntry}
     * @memberof CraftingRecipe
     */
    'sideProduct'?: ItemRecipeEntry;
}
/**
 * @type CraftingRecipeMaterialsInner
 * @export
 */
export type CraftingRecipeMaterialsInner = CharacterResourceRecipeEntry | ItemRecipeEntry | MaterialRecipeEntry;

/**
 * 
 * @export
 * @interface CurrencyCalculation
 */
export interface CurrencyCalculation {
    /**
     * 
     * @type {string}
     * @memberof CurrencyCalculation
     */
    'baseCurrency': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyCalculation
     */
    'baseCurrencyShortForm': string;
    /**
     * 
     * @type {Array<CurrencyCalculationEntry>}
     * @memberof CurrencyCalculation
     */
    'calculationEntries': Array<CurrencyCalculationEntry>;
}
/**
 * 
 * @export
 * @interface CurrencyCalculationEntry
 */
export interface CurrencyCalculationEntry {
    /**
     * 
     * @type {string}
     * @memberof CurrencyCalculationEntry
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyCalculationEntry
     */
    'currencyShortForm': string;
    /**
     * 
     * @type {number}
     * @memberof CurrencyCalculationEntry
     */
    'factor'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ERarity = {
    Common: 'COMMON',
    Uncommon: 'UNCOMMON',
    Rare: 'RARE',
    Epic: 'EPIC',
    Legendary: 'LEGENDARY',
    Godlike: 'GODLIKE'
} as const;

export type ERarity = typeof ERarity[keyof typeof ERarity];


/**
 * @type GetAllItems200ResponseInner
 * @export
 */
export type GetAllItems200ResponseInner = Armor | Item | Jewellery | Shield | Weapon;

/**
 * @type GetPermissions200ResponseInner
 * @export
 */
export type GetPermissions200ResponseInner = GrantedUniverseAuthorityDTO | RoleAuthorityDTO;

/**
 * 
 * @export
 * @interface GrantedUniverseAuthorityDTO
 */
export interface GrantedUniverseAuthorityDTO {
    /**
     * 
     * @type {string}
     * @memberof GrantedUniverseAuthorityDTO
     */
    'permission': string;
    /**
     * 
     * @type {string}
     * @memberof GrantedUniverseAuthorityDTO
     */
    'universe': string;
}
/**
 * 
 * @export
 * @interface GrantedUniverseAuthorityDTOAllOf
 */
export interface GrantedUniverseAuthorityDTOAllOf {
    /**
     * 
     * @type {string}
     * @memberof GrantedUniverseAuthorityDTOAllOf
     */
    'permission'?: string;
    /**
     * 
     * @type {string}
     * @memberof GrantedUniverseAuthorityDTOAllOf
     */
    'universe'?: string;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'effect': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'maximumStackSize': number;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'minimumStackSize': number;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'note': string;
    /**
     * 
     * @type {ERarity}
     * @memberof Item
     */
    'rarity': ERarity;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'requirement': string;
    /**
     * 
     * @type {ItemType}
     * @memberof Item
     */
    'subtype': ItemType;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'tier': number;
    /**
     * 
     * @type {ItemType}
     * @memberof Item
     */
    'type': ItemType;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'vendorPrice': number;
}


/**
 * 
 * @export
 * @interface ItemRecipeEntry
 */
export interface ItemRecipeEntry {
    /**
     * 
     * @type {number}
     * @memberof ItemRecipeEntry
     */
    'amountOfRequiredUnits'?: number;
    /**
     * 
     * @type {Item}
     * @memberof ItemRecipeEntry
     */
    'item': Item;
}
/**
 * 
 * @export
 * @interface ItemRecipeEntryAllOf
 */
export interface ItemRecipeEntryAllOf {
    /**
     * 
     * @type {number}
     * @memberof ItemRecipeEntryAllOf
     */
    'amountOfRequiredUnits'?: number;
    /**
     * 
     * @type {Item}
     * @memberof ItemRecipeEntryAllOf
     */
    'item'?: Item;
}
/**
 * 
 * @export
 * @interface ItemType
 */
export interface ItemType {
    /**
     * 
     * @type {string}
     * @memberof ItemType
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemType
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ItemType
     */
    'typeRestriction': ItemTypeTypeRestrictionEnum;
}

export const ItemTypeTypeRestrictionEnum = {
    Item: 'ITEM',
    Equipment: 'EQUIPMENT',
    Jewellery: 'JEWELLERY',
    Weapon: 'WEAPON',
    DefensiveItem: 'DEFENSIVE_ITEM',
    Shield: 'SHIELD',
    Handheld: 'HANDHELD',
    Armor: 'ARMOR'
} as const;

export type ItemTypeTypeRestrictionEnum = typeof ItemTypeTypeRestrictionEnum[keyof typeof ItemTypeTypeRestrictionEnum];

/**
 * 
 * @export
 * @interface ItemTypeTranslation
 */
export interface ItemTypeTranslation {
    /**
     * 
     * @type {Set<ItemType>}
     * @memberof ItemTypeTranslation
     */
    'broaderVariants': Set<ItemType>;
    /**
     * 
     * @type {string}
     * @memberof ItemTypeTranslation
     */
    'id'?: string;
    /**
     * 
     * @type {ItemType}
     * @memberof ItemTypeTranslation
     */
    'type': ItemType;
}
/**
 * 
 * @export
 * @interface Jewellery
 */
export interface Jewellery {
    /**
     * 
     * @type {string}
     * @memberof Jewellery
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Jewellery
     */
    'effect': string;
    /**
     * 
     * @type {string}
     * @memberof Jewellery
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Jewellery
     */
    'maximumStackSize': number;
    /**
     * 
     * @type {number}
     * @memberof Jewellery
     */
    'minimumStackSize': number;
    /**
     * 
     * @type {string}
     * @memberof Jewellery
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Jewellery
     */
    'note': string;
    /**
     * 
     * @type {ERarity}
     * @memberof Jewellery
     */
    'rarity': ERarity;
    /**
     * 
     * @type {string}
     * @memberof Jewellery
     */
    'requirement': string;
    /**
     * 
     * @type {ItemType}
     * @memberof Jewellery
     */
    'subtype': ItemType;
    /**
     * 
     * @type {number}
     * @memberof Jewellery
     */
    'tier': number;
    /**
     * 
     * @type {ItemType}
     * @memberof Jewellery
     */
    'type': ItemType;
    /**
     * 
     * @type {number}
     * @memberof Jewellery
     */
    'vendorPrice': number;
    /**
     * 
     * @type {Material}
     * @memberof Jewellery
     */
    'material': Material;
    /**
     * 
     * @type {number}
     * @memberof Jewellery
     */
    'upgradeSlots': number;
}


/**
 * 
 * @export
 * @interface JewelleryAllOf
 */
export interface JewelleryAllOf {
    /**
     * 
     * @type {Material}
     * @memberof JewelleryAllOf
     */
    'material'?: Material;
    /**
     * 
     * @type {number}
     * @memberof JewelleryAllOf
     */
    'upgradeSlots'?: number;
}
/**
 * 
 * @export
 * @interface Material
 */
export interface Material {
    /**
     * 
     * @type {string}
     * @memberof Material
     */
    'id'?: string;
    /**
     * 
     * @type {Array<MaterialItem>}
     * @memberof Material
     */
    'items': Array<MaterialItem>;
    /**
     * 
     * @type {string}
     * @memberof Material
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface MaterialItem
 */
export interface MaterialItem {
    /**
     * 
     * @type {number}
     * @memberof MaterialItem
     */
    'amount'?: number;
    /**
     * 
     * @type {Item}
     * @memberof MaterialItem
     */
    'item': Item;
}
/**
 * 
 * @export
 * @interface MaterialRecipeEntry
 */
export interface MaterialRecipeEntry {
    /**
     * 
     * @type {number}
     * @memberof MaterialRecipeEntry
     */
    'amountOfRequiredUnits'?: number;
    /**
     * 
     * @type {Material}
     * @memberof MaterialRecipeEntry
     */
    'material': Material;
}
/**
 * 
 * @export
 * @interface MaterialRecipeEntryAllOf
 */
export interface MaterialRecipeEntryAllOf {
    /**
     * 
     * @type {number}
     * @memberof MaterialRecipeEntryAllOf
     */
    'amountOfRequiredUnits'?: number;
    /**
     * 
     * @type {Material}
     * @memberof MaterialRecipeEntryAllOf
     */
    'material'?: Material;
}
/**
 * 
 * @export
 * @interface MultiplicativeUpgradeEffect
 */
export interface MultiplicativeUpgradeEffect {
    /**
     * 
     * @type {string}
     * @memberof MultiplicativeUpgradeEffect
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof MultiplicativeUpgradeEffect
     */
    'upgradeManipulator': MultiplicativeUpgradeEffectUpgradeManipulatorEnum;
    /**
     * 
     * @type {number}
     * @memberof MultiplicativeUpgradeEffect
     */
    'factor'?: number;
}

export const MultiplicativeUpgradeEffectUpgradeManipulatorEnum = {
    None: 'NONE',
    Slots: 'SLOTS',
    Damage: 'DAMAGE',
    Hit: 'HIT',
    Initiative: 'INITIATIVE',
    Armor: 'ARMOR',
    Weight: 'WEIGHT'
} as const;

export type MultiplicativeUpgradeEffectUpgradeManipulatorEnum = typeof MultiplicativeUpgradeEffectUpgradeManipulatorEnum[keyof typeof MultiplicativeUpgradeEffectUpgradeManipulatorEnum];

/**
 * 
 * @export
 * @interface MultiplicativeUpgradeEffectAllOf
 */
export interface MultiplicativeUpgradeEffectAllOf {
    /**
     * 
     * @type {number}
     * @memberof MultiplicativeUpgradeEffectAllOf
     */
    'factor'?: number;
}
/**
 * 
 * @export
 * @interface PasswordChange
 */
export interface PasswordChange {
    /**
     * 
     * @type {string}
     * @memberof PasswordChange
     */
    'newPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordChange
     */
    'oldPassword'?: string;
}
/**
 * 
 * @export
 * @interface PnPUser
 */
export interface PnPUser {
    /**
     * 
     * @type {string}
     * @memberof PnPUser
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PnPUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PnPUser
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface PnPUserCreation
 */
export interface PnPUserCreation {
    /**
     * 
     * @type {Array<GetPermissions200ResponseInner>}
     * @memberof PnPUserCreation
     */
    'authorities': Array<GetPermissions200ResponseInner>;
    /**
     * 
     * @type {string}
     * @memberof PnPUserCreation
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof PnPUserCreation
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PnPUserCreation
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof PnPUserCreation
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface PrimaryAttribute
 */
export interface PrimaryAttribute {
    /**
     * 
     * @type {string}
     * @memberof PrimaryAttribute
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrimaryAttribute
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PrimaryAttribute
     */
    'shortName': string;
}
/**
 * 
 * @export
 * @interface PrimaryAttributeDependency
 */
export interface PrimaryAttributeDependency {
    /**
     * 
     * @type {number}
     * @memberof PrimaryAttributeDependency
     */
    'factor'?: number;
    /**
     * 
     * @type {PrimaryAttribute}
     * @memberof PrimaryAttributeDependency
     */
    'primaryAttribute': PrimaryAttribute;
}
/**
 * 
 * @export
 * @interface RoleAuthorityDTO
 */
export interface RoleAuthorityDTO {
    /**
     * 
     * @type {string}
     * @memberof RoleAuthorityDTO
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface RoleAuthorityDTOAllOf
 */
export interface RoleAuthorityDTOAllOf {
    /**
     * 
     * @type {string}
     * @memberof RoleAuthorityDTOAllOf
     */
    'role'?: string;
}
/**
 * 
 * @export
 * @interface SecondaryAttribute
 */
export interface SecondaryAttribute {
    /**
     * 
     * @type {boolean}
     * @memberof SecondaryAttribute
     */
    'consumable': boolean;
    /**
     * 
     * @type {string}
     * @memberof SecondaryAttribute
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecondaryAttribute
     */
    'name': string;
    /**
     * 
     * @type {Array<PrimaryAttributeDependency>}
     * @memberof SecondaryAttribute
     */
    'primaryAttributeDependencies': Array<PrimaryAttributeDependency>;
}
/**
 * 
 * @export
 * @interface Shield
 */
export interface Shield {
    /**
     * 
     * @type {string}
     * @memberof Shield
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Shield
     */
    'effect': string;
    /**
     * 
     * @type {string}
     * @memberof Shield
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'maximumStackSize': number;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'minimumStackSize': number;
    /**
     * 
     * @type {string}
     * @memberof Shield
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Shield
     */
    'note': string;
    /**
     * 
     * @type {ERarity}
     * @memberof Shield
     */
    'rarity': ERarity;
    /**
     * 
     * @type {string}
     * @memberof Shield
     */
    'requirement': string;
    /**
     * 
     * @type {ItemType}
     * @memberof Shield
     */
    'subtype': ItemType;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'tier': number;
    /**
     * 
     * @type {ItemType}
     * @memberof Shield
     */
    'type': ItemType;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'vendorPrice': number;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'armor': number;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'hit': number;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'initiative': number;
    /**
     * 
     * @type {Material}
     * @memberof Shield
     */
    'material': Material;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'upgradeSlots': number;
    /**
     * 
     * @type {number}
     * @memberof Shield
     */
    'weight': number;
}


/**
 * 
 * @export
 * @interface ShieldAllOf
 */
export interface ShieldAllOf {
    /**
     * 
     * @type {number}
     * @memberof ShieldAllOf
     */
    'armor'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShieldAllOf
     */
    'hit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShieldAllOf
     */
    'initiative'?: number;
    /**
     * 
     * @type {Material}
     * @memberof ShieldAllOf
     */
    'material'?: Material;
    /**
     * 
     * @type {number}
     * @memberof ShieldAllOf
     */
    'upgradeSlots'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShieldAllOf
     */
    'weight'?: number;
}
/**
 * 
 * @export
 * @interface SimpleUpgradeEffect
 */
export interface SimpleUpgradeEffect {
    /**
     * 
     * @type {string}
     * @memberof SimpleUpgradeEffect
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SimpleUpgradeEffect
     */
    'upgradeManipulator': SimpleUpgradeEffectUpgradeManipulatorEnum;
}

export const SimpleUpgradeEffectUpgradeManipulatorEnum = {
    None: 'NONE',
    Slots: 'SLOTS',
    Damage: 'DAMAGE',
    Hit: 'HIT',
    Initiative: 'INITIATIVE',
    Armor: 'ARMOR',
    Weight: 'WEIGHT'
} as const;

export type SimpleUpgradeEffectUpgradeManipulatorEnum = typeof SimpleUpgradeEffectUpgradeManipulatorEnum[keyof typeof SimpleUpgradeEffectUpgradeManipulatorEnum];

/**
 * 
 * @export
 * @interface Spell
 */
export interface Spell {
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'castTime': string;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'cost': string;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'effect': string;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Spell
     */
    'name': string;
    /**
     * 
     * @type {Array<Talent>}
     * @memberof Spell
     */
    'talents': Array<Talent>;
    /**
     * 
     * @type {number}
     * @memberof Spell
     */
    'tier': number;
}
/**
 * 
 * @export
 * @interface Talent
 */
export interface Talent {
    /**
     * 
     * @type {PrimaryAttribute}
     * @memberof Talent
     */
    'firstAttribute': PrimaryAttribute;
    /**
     * 
     * @type {string}
     * @memberof Talent
     */
    'group': string;
    /**
     * 
     * @type {string}
     * @memberof Talent
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Talent
     */
    'name': string;
    /**
     * 
     * @type {PrimaryAttribute}
     * @memberof Talent
     */
    'secondAttribute': PrimaryAttribute;
    /**
     * 
     * @type {PrimaryAttribute}
     * @memberof Talent
     */
    'thirdAttribute': PrimaryAttribute;
}
/**
 * 
 * @export
 * @interface Universe
 */
export interface Universe {
    /**
     * 
     * @type {string}
     * @memberof Universe
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof Universe
     */
    'name': string;
    /**
     * 
     * @type {UniverseSettings}
     * @memberof Universe
     */
    'settings': UniverseSettings;
    /**
     * 
     * @type {string}
     * @memberof Universe
     */
    'shortDescription': string;
}
/**
 * 
 * @export
 * @interface UniverseSettings
 */
export interface UniverseSettings {
    /**
     * 
     * @type {CurrencyCalculation}
     * @memberof UniverseSettings
     */
    'currencyCalculation': CurrencyCalculation;
    /**
     * 
     * @type {number}
     * @memberof UniverseSettings
     */
    'wearFactor': number;
}
/**
 * 
 * @export
 * @interface Upgrade
 */
export interface Upgrade {
    /**
     * 
     * @type {Array<UpgradeEffectsInner>}
     * @memberof Upgrade
     */
    'effects': Array<UpgradeEffectsInner>;
    /**
     * 
     * @type {string}
     * @memberof Upgrade
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Upgrade
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Upgrade
     */
    'slots': number;
    /**
     * 
     * @type {ItemType}
     * @memberof Upgrade
     */
    'target': ItemType;
    /**
     * 
     * @type {number}
     * @memberof Upgrade
     */
    'vendorPrice': number;
}
/**
 * 
 * @export
 * @interface UpgradeEffect
 */
export interface UpgradeEffect {
    /**
     * 
     * @type {string}
     * @memberof UpgradeEffect
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof UpgradeEffect
     */
    'upgradeManipulator': UpgradeEffectUpgradeManipulatorEnum;
}

export const UpgradeEffectUpgradeManipulatorEnum = {
    None: 'NONE',
    Slots: 'SLOTS',
    Damage: 'DAMAGE',
    Hit: 'HIT',
    Initiative: 'INITIATIVE',
    Armor: 'ARMOR',
    Weight: 'WEIGHT'
} as const;

export type UpgradeEffectUpgradeManipulatorEnum = typeof UpgradeEffectUpgradeManipulatorEnum[keyof typeof UpgradeEffectUpgradeManipulatorEnum];

/**
 * @type UpgradeEffectsInner
 * @export
 */
export type UpgradeEffectsInner = AdditiveUpgradeEffect | MultiplicativeUpgradeEffect | SimpleUpgradeEffect;

/**
 * 
 * @export
 * @interface UpgradeRecipe
 */
export interface UpgradeRecipe {
    /**
     * 
     * @type {string}
     * @memberof UpgradeRecipe
     */
    'id'?: string;
    /**
     * 
     * @type {Array<CraftingRecipeMaterialsInner>}
     * @memberof UpgradeRecipe
     */
    'materials': Array<CraftingRecipeMaterialsInner>;
    /**
     * 
     * @type {Array<Upgrade>}
     * @memberof UpgradeRecipe
     */
    'requiredUpgrades': Array<Upgrade>;
    /**
     * 
     * @type {string}
     * @memberof UpgradeRecipe
     */
    'requirement': string;
    /**
     * 
     * @type {Upgrade}
     * @memberof UpgradeRecipe
     */
    'upgrade': Upgrade;
}
/**
 * 
 * @export
 * @interface UserUniversePermissionDTO
 */
export interface UserUniversePermissionDTO {
    /**
     * 
     * @type {string}
     * @memberof UserUniversePermissionDTO
     */
    'displayName': string;
    /**
     * 
     * @type {GrantedUniverseAuthorityDTO}
     * @memberof UserUniversePermissionDTO
     */
    'dto': GrantedUniverseAuthorityDTO;
}
/**
 * 
 * @export
 * @interface Weapon
 */
export interface Weapon {
    /**
     * 
     * @type {string}
     * @memberof Weapon
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Weapon
     */
    'effect': string;
    /**
     * 
     * @type {string}
     * @memberof Weapon
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'maximumStackSize': number;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'minimumStackSize': number;
    /**
     * 
     * @type {string}
     * @memberof Weapon
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Weapon
     */
    'note': string;
    /**
     * 
     * @type {ERarity}
     * @memberof Weapon
     */
    'rarity': ERarity;
    /**
     * 
     * @type {string}
     * @memberof Weapon
     */
    'requirement': string;
    /**
     * 
     * @type {ItemType}
     * @memberof Weapon
     */
    'subtype': ItemType;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'tier': number;
    /**
     * 
     * @type {ItemType}
     * @memberof Weapon
     */
    'type': ItemType;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'vendorPrice': number;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'damage': number;
    /**
     * 
     * @type {string}
     * @memberof Weapon
     */
    'dice': string;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'hit': number;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'initiative': number;
    /**
     * 
     * @type {Material}
     * @memberof Weapon
     */
    'material': Material;
    /**
     * 
     * @type {number}
     * @memberof Weapon
     */
    'upgradeSlots': number;
}


/**
 * 
 * @export
 * @interface WeaponAllOf
 */
export interface WeaponAllOf {
    /**
     * 
     * @type {number}
     * @memberof WeaponAllOf
     */
    'damage'?: number;
    /**
     * 
     * @type {string}
     * @memberof WeaponAllOf
     */
    'dice'?: string;
    /**
     * 
     * @type {number}
     * @memberof WeaponAllOf
     */
    'hit'?: number;
    /**
     * 
     * @type {number}
     * @memberof WeaponAllOf
     */
    'initiative'?: number;
    /**
     * 
     * @type {Material}
     * @memberof WeaponAllOf
     */
    'material'?: Material;
    /**
     * 
     * @type {number}
     * @memberof WeaponAllOf
     */
    'upgradeSlots'?: number;
}

/**
 * AuthenticationServiceApi - axios parameter creator
 * @export
 */
export const AuthenticationServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the username of the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsername: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/authentication/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationServiceApi - functional programming interface
 * @export
 */
export const AuthenticationServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the username of the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsername(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsername(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationServiceApi - factory interface
 * @export
 */
export const AuthenticationServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the username of the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsername(options?: any): AxiosPromise<string> {
            return localVarFp.getUsername(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationServiceApi - object-oriented interface
 * @export
 * @class AuthenticationServiceApi
 * @extends {BaseAPI}
 */
export class AuthenticationServiceApi extends BaseAPI {
    /**
     * 
     * @summary Returns the username of the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationServiceApi
     */
    public getUsername(options?: AxiosRequestConfig) {
        return AuthenticationServiceApiFp(this.configuration).getUsername(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BackupServiceApi - axios parameter creator
 * @export
 */
export const BackupServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a backup of the nexus
         * @param {Array<string>} [universes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBackup: async (universes?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/backup/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (universes) {
                localVarQueryParameter['universes'] = universes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import a backup to the nexus
         * @param {File} backup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importBackup: async (backup: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'backup' is not null or undefined
            assertParamExists('importBackup', 'backup', backup)
            const localVarPath = `/api/backup/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (backup !== undefined) {
                localVarQueryParameter['backup'] = backup;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackupServiceApi - functional programming interface
 * @export
 */
export const BackupServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BackupServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a backup of the nexus
         * @param {Array<string>} [universes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportBackup(universes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportBackup(universes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import a backup to the nexus
         * @param {File} backup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importBackup(backup: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importBackup(backup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BackupServiceApi - factory interface
 * @export
 */
export const BackupServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BackupServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a backup of the nexus
         * @param {Array<string>} [universes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportBackup(universes?: Array<string>, options?: any): AxiosPromise<object> {
            return localVarFp.exportBackup(universes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import a backup to the nexus
         * @param {File} backup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importBackup(backup: File, options?: any): AxiosPromise<void> {
            return localVarFp.importBackup(backup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BackupServiceApi - object-oriented interface
 * @export
 * @class BackupServiceApi
 * @extends {BaseAPI}
 */
export class BackupServiceApi extends BaseAPI {
    /**
     * 
     * @summary Creates a backup of the nexus
     * @param {Array<string>} [universes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupServiceApi
     */
    public exportBackup(universes?: Array<string>, options?: AxiosRequestConfig) {
        return BackupServiceApiFp(this.configuration).exportBackup(universes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import a backup to the nexus
     * @param {File} backup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupServiceApi
     */
    public importBackup(backup: File, options?: AxiosRequestConfig) {
        return BackupServiceApiFp(this.configuration).importBackup(backup, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CraftingRecipeServiceApi - axios parameter creator
 * @export
 */
export const CraftingRecipeServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllCraftingRecipes: async (universe: string, ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteAllCraftingRecipes', 'universe', universe)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteAllCraftingRecipes', 'ids', ids)
            const localVarPath = `/api/{universe}/crafting-recipes`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCraftingRecipe: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteCraftingRecipe', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCraftingRecipe', 'id', id)
            const localVarPath = `/api/{universe}/crafting-recipes/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCraftingRecipes: async (universe: string, ids?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getAllCraftingRecipes', 'universe', universe)
            const localVarPath = `/api/{universe}/crafting-recipes`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCraftingRecipe: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getCraftingRecipe', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCraftingRecipe', 'id', id)
            const localVarPath = `/api/{universe}/crafting-recipes/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<CraftingRecipe>} craftingRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllCraftingRecipes: async (universe: string, craftingRecipe: Array<CraftingRecipe>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('insertAllCraftingRecipes', 'universe', universe)
            // verify required parameter 'craftingRecipe' is not null or undefined
            assertParamExists('insertAllCraftingRecipes', 'craftingRecipe', craftingRecipe)
            const localVarPath = `/api/{universe}/crafting-recipes`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(craftingRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {CraftingRecipe} craftingRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCraftingRecipe: async (universe: string, id: string, craftingRecipe: CraftingRecipe, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('updateCraftingRecipe', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCraftingRecipe', 'id', id)
            // verify required parameter 'craftingRecipe' is not null or undefined
            assertParamExists('updateCraftingRecipe', 'craftingRecipe', craftingRecipe)
            const localVarPath = `/api/{universe}/crafting-recipes/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(craftingRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CraftingRecipeServiceApi - functional programming interface
 * @export
 */
export const CraftingRecipeServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CraftingRecipeServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllCraftingRecipes(universe: string, ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllCraftingRecipes(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCraftingRecipe(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCraftingRecipe(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCraftingRecipes(universe: string, ids?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CraftingRecipe>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCraftingRecipes(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCraftingRecipe(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CraftingRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCraftingRecipe(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<CraftingRecipe>} craftingRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertAllCraftingRecipes(universe: string, craftingRecipe: Array<CraftingRecipe>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CraftingRecipe>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertAllCraftingRecipes(universe, craftingRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {CraftingRecipe} craftingRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCraftingRecipe(universe: string, id: string, craftingRecipe: CraftingRecipe, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CraftingRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCraftingRecipe(universe, id, craftingRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CraftingRecipeServiceApi - factory interface
 * @export
 */
export const CraftingRecipeServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CraftingRecipeServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllCraftingRecipes(universe: string, ids: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllCraftingRecipes(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCraftingRecipe(universe: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCraftingRecipe(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCraftingRecipes(universe: string, ids?: Array<string>, options?: any): AxiosPromise<Array<CraftingRecipe>> {
            return localVarFp.getAllCraftingRecipes(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCraftingRecipe(universe: string, id: string, options?: any): AxiosPromise<CraftingRecipe> {
            return localVarFp.getCraftingRecipe(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<CraftingRecipe>} craftingRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllCraftingRecipes(universe: string, craftingRecipe: Array<CraftingRecipe>, options?: any): AxiosPromise<Array<CraftingRecipe>> {
            return localVarFp.insertAllCraftingRecipes(universe, craftingRecipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {CraftingRecipe} craftingRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCraftingRecipe(universe: string, id: string, craftingRecipe: CraftingRecipe, options?: any): AxiosPromise<CraftingRecipe> {
            return localVarFp.updateCraftingRecipe(universe, id, craftingRecipe, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CraftingRecipeServiceApi - object-oriented interface
 * @export
 * @class CraftingRecipeServiceApi
 * @extends {BaseAPI}
 */
export class CraftingRecipeServiceApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all objects with the given ids from the database
     * @param {string} universe 
     * @param {Array<string>} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CraftingRecipeServiceApi
     */
    public deleteAllCraftingRecipes(universe: string, ids: Array<string>, options?: AxiosRequestConfig) {
        return CraftingRecipeServiceApiFp(this.configuration).deleteAllCraftingRecipes(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CraftingRecipeServiceApi
     */
    public deleteCraftingRecipe(universe: string, id: string, options?: AxiosRequestConfig) {
        return CraftingRecipeServiceApiFp(this.configuration).deleteCraftingRecipe(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all objects from the database
     * @param {string} universe 
     * @param {Array<string>} [ids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CraftingRecipeServiceApi
     */
    public getAllCraftingRecipes(universe: string, ids?: Array<string>, options?: AxiosRequestConfig) {
        return CraftingRecipeServiceApiFp(this.configuration).getAllCraftingRecipes(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CraftingRecipeServiceApi
     */
    public getCraftingRecipe(universe: string, id: string, options?: AxiosRequestConfig) {
        return CraftingRecipeServiceApiFp(this.configuration).getCraftingRecipe(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inserts the objects into the database
     * @param {string} universe 
     * @param {Array<CraftingRecipe>} craftingRecipe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CraftingRecipeServiceApi
     */
    public insertAllCraftingRecipes(universe: string, craftingRecipe: Array<CraftingRecipe>, options?: AxiosRequestConfig) {
        return CraftingRecipeServiceApiFp(this.configuration).insertAllCraftingRecipes(universe, craftingRecipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an object in the database
     * @param {string} universe 
     * @param {string} id 
     * @param {CraftingRecipe} craftingRecipe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CraftingRecipeServiceApi
     */
    public updateCraftingRecipe(universe: string, id: string, craftingRecipe: CraftingRecipe, options?: AxiosRequestConfig) {
        return CraftingRecipeServiceApiFp(this.configuration).updateCraftingRecipe(universe, id, craftingRecipe, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemServiceApi - axios parameter creator
 * @export
 */
export const ItemServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllItems: async (universe: string, ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteAllItems', 'universe', universe)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteAllItems', 'ids', ids)
            const localVarPath = `/api/{universe}/items`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteItem', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItem', 'id', id)
            const localVarPath = `/api/{universe}/items/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItems: async (universe: string, ids?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getAllItems', 'universe', universe)
            const localVarPath = `/api/{universe}/items`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getItem', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItem', 'id', id)
            const localVarPath = `/api/{universe}/items/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<GetAllItems200ResponseInner>} getAllItems200ResponseInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllItems: async (universe: string, getAllItems200ResponseInner: Array<GetAllItems200ResponseInner>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('insertAllItems', 'universe', universe)
            // verify required parameter 'getAllItems200ResponseInner' is not null or undefined
            assertParamExists('insertAllItems', 'getAllItems200ResponseInner', getAllItems200ResponseInner)
            const localVarPath = `/api/{universe}/items`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAllItems200ResponseInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {GetAllItems200ResponseInner} getAllItems200ResponseInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem: async (universe: string, id: string, getAllItems200ResponseInner: GetAllItems200ResponseInner, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('updateItem', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateItem', 'id', id)
            // verify required parameter 'getAllItems200ResponseInner' is not null or undefined
            assertParamExists('updateItem', 'getAllItems200ResponseInner', getAllItems200ResponseInner)
            const localVarPath = `/api/{universe}/items/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAllItems200ResponseInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemServiceApi - functional programming interface
 * @export
 */
export const ItemServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllItems(universe: string, ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllItems(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItem(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllItems(universe: string, ids?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllItems200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllItems(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItem(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllItems200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItem(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<GetAllItems200ResponseInner>} getAllItems200ResponseInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertAllItems(universe: string, getAllItems200ResponseInner: Array<GetAllItems200ResponseInner>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllItems200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertAllItems(universe, getAllItems200ResponseInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {GetAllItems200ResponseInner} getAllItems200ResponseInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItem(universe: string, id: string, getAllItems200ResponseInner: GetAllItems200ResponseInner, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllItems200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItem(universe, id, getAllItems200ResponseInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemServiceApi - factory interface
 * @export
 */
export const ItemServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllItems(universe: string, ids: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllItems(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(universe: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItem(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItems(universe: string, ids?: Array<string>, options?: any): AxiosPromise<Array<GetAllItems200ResponseInner>> {
            return localVarFp.getAllItems(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(universe: string, id: string, options?: any): AxiosPromise<GetAllItems200ResponseInner> {
            return localVarFp.getItem(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<GetAllItems200ResponseInner>} getAllItems200ResponseInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllItems(universe: string, getAllItems200ResponseInner: Array<GetAllItems200ResponseInner>, options?: any): AxiosPromise<Array<GetAllItems200ResponseInner>> {
            return localVarFp.insertAllItems(universe, getAllItems200ResponseInner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {GetAllItems200ResponseInner} getAllItems200ResponseInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(universe: string, id: string, getAllItems200ResponseInner: GetAllItems200ResponseInner, options?: any): AxiosPromise<GetAllItems200ResponseInner> {
            return localVarFp.updateItem(universe, id, getAllItems200ResponseInner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemServiceApi - object-oriented interface
 * @export
 * @class ItemServiceApi
 * @extends {BaseAPI}
 */
export class ItemServiceApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all objects with the given ids from the database
     * @param {string} universe 
     * @param {Array<string>} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemServiceApi
     */
    public deleteAllItems(universe: string, ids: Array<string>, options?: AxiosRequestConfig) {
        return ItemServiceApiFp(this.configuration).deleteAllItems(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemServiceApi
     */
    public deleteItem(universe: string, id: string, options?: AxiosRequestConfig) {
        return ItemServiceApiFp(this.configuration).deleteItem(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all objects from the database
     * @param {string} universe 
     * @param {Array<string>} [ids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemServiceApi
     */
    public getAllItems(universe: string, ids?: Array<string>, options?: AxiosRequestConfig) {
        return ItemServiceApiFp(this.configuration).getAllItems(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemServiceApi
     */
    public getItem(universe: string, id: string, options?: AxiosRequestConfig) {
        return ItemServiceApiFp(this.configuration).getItem(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inserts the objects into the database
     * @param {string} universe 
     * @param {Array<GetAllItems200ResponseInner>} getAllItems200ResponseInner 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemServiceApi
     */
    public insertAllItems(universe: string, getAllItems200ResponseInner: Array<GetAllItems200ResponseInner>, options?: AxiosRequestConfig) {
        return ItemServiceApiFp(this.configuration).insertAllItems(universe, getAllItems200ResponseInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an object in the database
     * @param {string} universe 
     * @param {string} id 
     * @param {GetAllItems200ResponseInner} getAllItems200ResponseInner 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemServiceApi
     */
    public updateItem(universe: string, id: string, getAllItems200ResponseInner: GetAllItems200ResponseInner, options?: AxiosRequestConfig) {
        return ItemServiceApiFp(this.configuration).updateItem(universe, id, getAllItems200ResponseInner, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemTypeServiceApi - axios parameter creator
 * @export
 */
export const ItemTypeServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllItemTypes: async (universe: string, ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteAllItemTypes', 'universe', universe)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteAllItemTypes', 'ids', ids)
            const localVarPath = `/api/{universe}/item-types`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemType: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteItemType', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemType', 'id', id)
            const localVarPath = `/api/{universe}/item-types/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemTypes: async (universe: string, ids?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getAllItemTypes', 'universe', universe)
            const localVarPath = `/api/{universe}/item-types`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemType: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getItemType', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemType', 'id', id)
            const localVarPath = `/api/{universe}/item-types/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<ItemType>} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllItemTypes: async (universe: string, itemType: Array<ItemType>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('insertAllItemTypes', 'universe', universe)
            // verify required parameter 'itemType' is not null or undefined
            assertParamExists('insertAllItemTypes', 'itemType', itemType)
            const localVarPath = `/api/{universe}/item-types`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {ItemType} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemType: async (universe: string, id: string, itemType: ItemType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('updateItemType', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateItemType', 'id', id)
            // verify required parameter 'itemType' is not null or undefined
            assertParamExists('updateItemType', 'itemType', itemType)
            const localVarPath = `/api/{universe}/item-types/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemTypeServiceApi - functional programming interface
 * @export
 */
export const ItemTypeServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemTypeServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllItemTypes(universe: string, ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllItemTypes(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemType(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemType(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllItemTypes(universe: string, ids?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllItemTypes(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemType(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemType(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<ItemType>} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertAllItemTypes(universe: string, itemType: Array<ItemType>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertAllItemTypes(universe, itemType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {ItemType} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemType(universe: string, id: string, itemType: ItemType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemType(universe, id, itemType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemTypeServiceApi - factory interface
 * @export
 */
export const ItemTypeServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemTypeServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllItemTypes(universe: string, ids: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllItemTypes(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemType(universe: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemType(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemTypes(universe: string, ids?: Array<string>, options?: any): AxiosPromise<Array<ItemType>> {
            return localVarFp.getAllItemTypes(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemType(universe: string, id: string, options?: any): AxiosPromise<ItemType> {
            return localVarFp.getItemType(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<ItemType>} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllItemTypes(universe: string, itemType: Array<ItemType>, options?: any): AxiosPromise<Array<ItemType>> {
            return localVarFp.insertAllItemTypes(universe, itemType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {ItemType} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemType(universe: string, id: string, itemType: ItemType, options?: any): AxiosPromise<ItemType> {
            return localVarFp.updateItemType(universe, id, itemType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemTypeServiceApi - object-oriented interface
 * @export
 * @class ItemTypeServiceApi
 * @extends {BaseAPI}
 */
export class ItemTypeServiceApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all objects with the given ids from the database
     * @param {string} universe 
     * @param {Array<string>} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTypeServiceApi
     */
    public deleteAllItemTypes(universe: string, ids: Array<string>, options?: AxiosRequestConfig) {
        return ItemTypeServiceApiFp(this.configuration).deleteAllItemTypes(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTypeServiceApi
     */
    public deleteItemType(universe: string, id: string, options?: AxiosRequestConfig) {
        return ItemTypeServiceApiFp(this.configuration).deleteItemType(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all objects from the database
     * @param {string} universe 
     * @param {Array<string>} [ids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTypeServiceApi
     */
    public getAllItemTypes(universe: string, ids?: Array<string>, options?: AxiosRequestConfig) {
        return ItemTypeServiceApiFp(this.configuration).getAllItemTypes(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTypeServiceApi
     */
    public getItemType(universe: string, id: string, options?: AxiosRequestConfig) {
        return ItemTypeServiceApiFp(this.configuration).getItemType(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inserts the objects into the database
     * @param {string} universe 
     * @param {Array<ItemType>} itemType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTypeServiceApi
     */
    public insertAllItemTypes(universe: string, itemType: Array<ItemType>, options?: AxiosRequestConfig) {
        return ItemTypeServiceApiFp(this.configuration).insertAllItemTypes(universe, itemType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an object in the database
     * @param {string} universe 
     * @param {string} id 
     * @param {ItemType} itemType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTypeServiceApi
     */
    public updateItemType(universe: string, id: string, itemType: ItemType, options?: AxiosRequestConfig) {
        return ItemTypeServiceApiFp(this.configuration).updateItemType(universe, id, itemType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemTypeTranslationServiceApi - axios parameter creator
 * @export
 */
export const ItemTypeTranslationServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllItemTypeTranslations: async (universe: string, ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteAllItemTypeTranslations', 'universe', universe)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteAllItemTypeTranslations', 'ids', ids)
            const localVarPath = `/api/{universe}/item-type-translations`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemTypeTranslation: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteItemTypeTranslation', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemTypeTranslation', 'id', id)
            const localVarPath = `/api/{universe}/item-type-translations/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemTypeTranslations: async (universe: string, ids?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getAllItemTypeTranslations', 'universe', universe)
            const localVarPath = `/api/{universe}/item-type-translations`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemTypeTranslation: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getItemTypeTranslation', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemTypeTranslation', 'id', id)
            const localVarPath = `/api/{universe}/item-type-translations/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<ItemTypeTranslation>} itemTypeTranslation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllItemTypeTranslations: async (universe: string, itemTypeTranslation: Array<ItemTypeTranslation>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('insertAllItemTypeTranslations', 'universe', universe)
            // verify required parameter 'itemTypeTranslation' is not null or undefined
            assertParamExists('insertAllItemTypeTranslations', 'itemTypeTranslation', itemTypeTranslation)
            const localVarPath = `/api/{universe}/item-type-translations`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemTypeTranslation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {ItemTypeTranslation} itemTypeTranslation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemTypeTranslation: async (universe: string, id: string, itemTypeTranslation: ItemTypeTranslation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('updateItemTypeTranslation', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateItemTypeTranslation', 'id', id)
            // verify required parameter 'itemTypeTranslation' is not null or undefined
            assertParamExists('updateItemTypeTranslation', 'itemTypeTranslation', itemTypeTranslation)
            const localVarPath = `/api/{universe}/item-type-translations/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemTypeTranslation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemTypeTranslationServiceApi - functional programming interface
 * @export
 */
export const ItemTypeTranslationServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemTypeTranslationServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllItemTypeTranslations(universe: string, ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllItemTypeTranslations(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemTypeTranslation(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemTypeTranslation(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllItemTypeTranslations(universe: string, ids?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemTypeTranslation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllItemTypeTranslations(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemTypeTranslation(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTypeTranslation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemTypeTranslation(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<ItemTypeTranslation>} itemTypeTranslation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertAllItemTypeTranslations(universe: string, itemTypeTranslation: Array<ItemTypeTranslation>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemTypeTranslation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertAllItemTypeTranslations(universe, itemTypeTranslation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {ItemTypeTranslation} itemTypeTranslation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemTypeTranslation(universe: string, id: string, itemTypeTranslation: ItemTypeTranslation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemTypeTranslation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemTypeTranslation(universe, id, itemTypeTranslation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemTypeTranslationServiceApi - factory interface
 * @export
 */
export const ItemTypeTranslationServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemTypeTranslationServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllItemTypeTranslations(universe: string, ids: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllItemTypeTranslations(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemTypeTranslation(universe: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItemTypeTranslation(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemTypeTranslations(universe: string, ids?: Array<string>, options?: any): AxiosPromise<Array<ItemTypeTranslation>> {
            return localVarFp.getAllItemTypeTranslations(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemTypeTranslation(universe: string, id: string, options?: any): AxiosPromise<ItemTypeTranslation> {
            return localVarFp.getItemTypeTranslation(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<ItemTypeTranslation>} itemTypeTranslation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllItemTypeTranslations(universe: string, itemTypeTranslation: Array<ItemTypeTranslation>, options?: any): AxiosPromise<Array<ItemTypeTranslation>> {
            return localVarFp.insertAllItemTypeTranslations(universe, itemTypeTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {ItemTypeTranslation} itemTypeTranslation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemTypeTranslation(universe: string, id: string, itemTypeTranslation: ItemTypeTranslation, options?: any): AxiosPromise<ItemTypeTranslation> {
            return localVarFp.updateItemTypeTranslation(universe, id, itemTypeTranslation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemTypeTranslationServiceApi - object-oriented interface
 * @export
 * @class ItemTypeTranslationServiceApi
 * @extends {BaseAPI}
 */
export class ItemTypeTranslationServiceApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all objects with the given ids from the database
     * @param {string} universe 
     * @param {Array<string>} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTypeTranslationServiceApi
     */
    public deleteAllItemTypeTranslations(universe: string, ids: Array<string>, options?: AxiosRequestConfig) {
        return ItemTypeTranslationServiceApiFp(this.configuration).deleteAllItemTypeTranslations(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTypeTranslationServiceApi
     */
    public deleteItemTypeTranslation(universe: string, id: string, options?: AxiosRequestConfig) {
        return ItemTypeTranslationServiceApiFp(this.configuration).deleteItemTypeTranslation(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all objects from the database
     * @param {string} universe 
     * @param {Array<string>} [ids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTypeTranslationServiceApi
     */
    public getAllItemTypeTranslations(universe: string, ids?: Array<string>, options?: AxiosRequestConfig) {
        return ItemTypeTranslationServiceApiFp(this.configuration).getAllItemTypeTranslations(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTypeTranslationServiceApi
     */
    public getItemTypeTranslation(universe: string, id: string, options?: AxiosRequestConfig) {
        return ItemTypeTranslationServiceApiFp(this.configuration).getItemTypeTranslation(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inserts the objects into the database
     * @param {string} universe 
     * @param {Array<ItemTypeTranslation>} itemTypeTranslation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTypeTranslationServiceApi
     */
    public insertAllItemTypeTranslations(universe: string, itemTypeTranslation: Array<ItemTypeTranslation>, options?: AxiosRequestConfig) {
        return ItemTypeTranslationServiceApiFp(this.configuration).insertAllItemTypeTranslations(universe, itemTypeTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an object in the database
     * @param {string} universe 
     * @param {string} id 
     * @param {ItemTypeTranslation} itemTypeTranslation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemTypeTranslationServiceApi
     */
    public updateItemTypeTranslation(universe: string, id: string, itemTypeTranslation: ItemTypeTranslation, options?: AxiosRequestConfig) {
        return ItemTypeTranslationServiceApiFp(this.configuration).updateItemTypeTranslation(universe, id, itemTypeTranslation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MaterialServiceApi - axios parameter creator
 * @export
 */
export const MaterialServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllMaterials: async (universe: string, ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteAllMaterials', 'universe', universe)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteAllMaterials', 'ids', ids)
            const localVarPath = `/api/{universe}/materials`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaterial: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteMaterial', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteMaterial', 'id', id)
            const localVarPath = `/api/{universe}/materials/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMaterials: async (universe: string, ids?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getAllMaterials', 'universe', universe)
            const localVarPath = `/api/{universe}/materials`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaterial: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getMaterial', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMaterial', 'id', id)
            const localVarPath = `/api/{universe}/materials/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<Material>} material 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllMaterials: async (universe: string, material: Array<Material>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('insertAllMaterials', 'universe', universe)
            // verify required parameter 'material' is not null or undefined
            assertParamExists('insertAllMaterials', 'material', material)
            const localVarPath = `/api/{universe}/materials`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(material, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {Material} material 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMaterial: async (universe: string, id: string, material: Material, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('updateMaterial', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMaterial', 'id', id)
            // verify required parameter 'material' is not null or undefined
            assertParamExists('updateMaterial', 'material', material)
            const localVarPath = `/api/{universe}/materials/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(material, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MaterialServiceApi - functional programming interface
 * @export
 */
export const MaterialServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MaterialServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllMaterials(universe: string, ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllMaterials(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMaterial(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMaterial(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMaterials(universe: string, ids?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Material>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMaterials(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaterial(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Material>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaterial(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<Material>} material 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertAllMaterials(universe: string, material: Array<Material>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Material>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertAllMaterials(universe, material, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {Material} material 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMaterial(universe: string, id: string, material: Material, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Material>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMaterial(universe, id, material, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MaterialServiceApi - factory interface
 * @export
 */
export const MaterialServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MaterialServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllMaterials(universe: string, ids: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllMaterials(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaterial(universe: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMaterial(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMaterials(universe: string, ids?: Array<string>, options?: any): AxiosPromise<Array<Material>> {
            return localVarFp.getAllMaterials(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaterial(universe: string, id: string, options?: any): AxiosPromise<Material> {
            return localVarFp.getMaterial(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<Material>} material 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllMaterials(universe: string, material: Array<Material>, options?: any): AxiosPromise<Array<Material>> {
            return localVarFp.insertAllMaterials(universe, material, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {Material} material 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMaterial(universe: string, id: string, material: Material, options?: any): AxiosPromise<Material> {
            return localVarFp.updateMaterial(universe, id, material, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MaterialServiceApi - object-oriented interface
 * @export
 * @class MaterialServiceApi
 * @extends {BaseAPI}
 */
export class MaterialServiceApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all objects with the given ids from the database
     * @param {string} universe 
     * @param {Array<string>} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialServiceApi
     */
    public deleteAllMaterials(universe: string, ids: Array<string>, options?: AxiosRequestConfig) {
        return MaterialServiceApiFp(this.configuration).deleteAllMaterials(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialServiceApi
     */
    public deleteMaterial(universe: string, id: string, options?: AxiosRequestConfig) {
        return MaterialServiceApiFp(this.configuration).deleteMaterial(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all objects from the database
     * @param {string} universe 
     * @param {Array<string>} [ids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialServiceApi
     */
    public getAllMaterials(universe: string, ids?: Array<string>, options?: AxiosRequestConfig) {
        return MaterialServiceApiFp(this.configuration).getAllMaterials(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialServiceApi
     */
    public getMaterial(universe: string, id: string, options?: AxiosRequestConfig) {
        return MaterialServiceApiFp(this.configuration).getMaterial(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inserts the objects into the database
     * @param {string} universe 
     * @param {Array<Material>} material 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialServiceApi
     */
    public insertAllMaterials(universe: string, material: Array<Material>, options?: AxiosRequestConfig) {
        return MaterialServiceApiFp(this.configuration).insertAllMaterials(universe, material, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an object in the database
     * @param {string} universe 
     * @param {string} id 
     * @param {Material} material 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialServiceApi
     */
    public updateMaterial(universe: string, id: string, material: Material, options?: AxiosRequestConfig) {
        return MaterialServiceApiFp(this.configuration).updateMaterial(universe, id, material, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PageServiceApi - axios parameter creator
 * @export
 */
export const PageServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} destination 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPage: async (destination: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'destination' is not null or undefined
            assertParamExists('getPage', 'destination', destination)
            const localVarPath = `/{destination}`
                .replace(`{${"destination"}}`, encodeURIComponent(String(destination)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PageServiceApi - functional programming interface
 * @export
 */
export const PageServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PageServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} destination 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPage(destination: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPage(destination, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PageServiceApi - factory interface
 * @export
 */
export const PageServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PageServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} destination 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPage(destination: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPage(destination, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PageServiceApi - object-oriented interface
 * @export
 * @class PageServiceApi
 * @extends {BaseAPI}
 */
export class PageServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} destination 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageServiceApi
     */
    public getPage(destination: string, options?: AxiosRequestConfig) {
        return PageServiceApiFp(this.configuration).getPage(destination, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PrimaryAttributeServiceApi - axios parameter creator
 * @export
 */
export const PrimaryAttributeServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllPrimaryAttributes: async (universe: string, ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteAllPrimaryAttributes', 'universe', universe)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteAllPrimaryAttributes', 'ids', ids)
            const localVarPath = `/{universe}/primary-attributes`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrimaryAttribute: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deletePrimaryAttribute', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePrimaryAttribute', 'id', id)
            const localVarPath = `/{universe}/primary-attributes/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPrimaryAttributes: async (universe: string, ids?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getAllPrimaryAttributes', 'universe', universe)
            const localVarPath = `/{universe}/primary-attributes`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrimaryAttribute: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getPrimaryAttribute', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPrimaryAttribute', 'id', id)
            const localVarPath = `/{universe}/primary-attributes/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<PrimaryAttribute>} primaryAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllPrimaryAttributes: async (universe: string, primaryAttribute: Array<PrimaryAttribute>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('insertAllPrimaryAttributes', 'universe', universe)
            // verify required parameter 'primaryAttribute' is not null or undefined
            assertParamExists('insertAllPrimaryAttributes', 'primaryAttribute', primaryAttribute)
            const localVarPath = `/{universe}/primary-attributes`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(primaryAttribute, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {PrimaryAttribute} primaryAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrimaryAttribute: async (universe: string, id: string, primaryAttribute: PrimaryAttribute, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('updatePrimaryAttribute', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePrimaryAttribute', 'id', id)
            // verify required parameter 'primaryAttribute' is not null or undefined
            assertParamExists('updatePrimaryAttribute', 'primaryAttribute', primaryAttribute)
            const localVarPath = `/{universe}/primary-attributes/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(primaryAttribute, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrimaryAttributeServiceApi - functional programming interface
 * @export
 */
export const PrimaryAttributeServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PrimaryAttributeServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllPrimaryAttributes(universe: string, ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllPrimaryAttributes(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePrimaryAttribute(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePrimaryAttribute(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPrimaryAttributes(universe: string, ids?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PrimaryAttribute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPrimaryAttributes(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrimaryAttribute(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrimaryAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrimaryAttribute(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<PrimaryAttribute>} primaryAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertAllPrimaryAttributes(universe: string, primaryAttribute: Array<PrimaryAttribute>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PrimaryAttribute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertAllPrimaryAttributes(universe, primaryAttribute, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {PrimaryAttribute} primaryAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePrimaryAttribute(universe: string, id: string, primaryAttribute: PrimaryAttribute, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrimaryAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePrimaryAttribute(universe, id, primaryAttribute, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PrimaryAttributeServiceApi - factory interface
 * @export
 */
export const PrimaryAttributeServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PrimaryAttributeServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllPrimaryAttributes(universe: string, ids: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllPrimaryAttributes(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrimaryAttribute(universe: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePrimaryAttribute(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPrimaryAttributes(universe: string, ids?: Array<string>, options?: any): AxiosPromise<Array<PrimaryAttribute>> {
            return localVarFp.getAllPrimaryAttributes(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrimaryAttribute(universe: string, id: string, options?: any): AxiosPromise<PrimaryAttribute> {
            return localVarFp.getPrimaryAttribute(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<PrimaryAttribute>} primaryAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllPrimaryAttributes(universe: string, primaryAttribute: Array<PrimaryAttribute>, options?: any): AxiosPromise<Array<PrimaryAttribute>> {
            return localVarFp.insertAllPrimaryAttributes(universe, primaryAttribute, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {PrimaryAttribute} primaryAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrimaryAttribute(universe: string, id: string, primaryAttribute: PrimaryAttribute, options?: any): AxiosPromise<PrimaryAttribute> {
            return localVarFp.updatePrimaryAttribute(universe, id, primaryAttribute, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PrimaryAttributeServiceApi - object-oriented interface
 * @export
 * @class PrimaryAttributeServiceApi
 * @extends {BaseAPI}
 */
export class PrimaryAttributeServiceApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all objects with the given ids from the database
     * @param {string} universe 
     * @param {Array<string>} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrimaryAttributeServiceApi
     */
    public deleteAllPrimaryAttributes(universe: string, ids: Array<string>, options?: AxiosRequestConfig) {
        return PrimaryAttributeServiceApiFp(this.configuration).deleteAllPrimaryAttributes(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrimaryAttributeServiceApi
     */
    public deletePrimaryAttribute(universe: string, id: string, options?: AxiosRequestConfig) {
        return PrimaryAttributeServiceApiFp(this.configuration).deletePrimaryAttribute(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all objects from the database
     * @param {string} universe 
     * @param {Array<string>} [ids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrimaryAttributeServiceApi
     */
    public getAllPrimaryAttributes(universe: string, ids?: Array<string>, options?: AxiosRequestConfig) {
        return PrimaryAttributeServiceApiFp(this.configuration).getAllPrimaryAttributes(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrimaryAttributeServiceApi
     */
    public getPrimaryAttribute(universe: string, id: string, options?: AxiosRequestConfig) {
        return PrimaryAttributeServiceApiFp(this.configuration).getPrimaryAttribute(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inserts the objects into the database
     * @param {string} universe 
     * @param {Array<PrimaryAttribute>} primaryAttribute 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrimaryAttributeServiceApi
     */
    public insertAllPrimaryAttributes(universe: string, primaryAttribute: Array<PrimaryAttribute>, options?: AxiosRequestConfig) {
        return PrimaryAttributeServiceApiFp(this.configuration).insertAllPrimaryAttributes(universe, primaryAttribute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an object in the database
     * @param {string} universe 
     * @param {string} id 
     * @param {PrimaryAttribute} primaryAttribute 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrimaryAttributeServiceApi
     */
    public updatePrimaryAttribute(universe: string, id: string, primaryAttribute: PrimaryAttribute, options?: AxiosRequestConfig) {
        return PrimaryAttributeServiceApiFp(this.configuration).updatePrimaryAttribute(universe, id, primaryAttribute, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SecondaryAttributeServiceApi - axios parameter creator
 * @export
 */
export const SecondaryAttributeServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllSecondaryAttributes: async (universe: string, ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteAllSecondaryAttributes', 'universe', universe)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteAllSecondaryAttributes', 'ids', ids)
            const localVarPath = `/{universe}/secondary-attributes`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecondaryAttribute: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteSecondaryAttribute', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSecondaryAttribute', 'id', id)
            const localVarPath = `/{universe}/secondary-attributes/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSecondaryAttributes: async (universe: string, ids?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getAllSecondaryAttributes', 'universe', universe)
            const localVarPath = `/{universe}/secondary-attributes`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecondaryAttribute: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getSecondaryAttribute', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSecondaryAttribute', 'id', id)
            const localVarPath = `/{universe}/secondary-attributes/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<SecondaryAttribute>} secondaryAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllSecondaryAttributes: async (universe: string, secondaryAttribute: Array<SecondaryAttribute>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('insertAllSecondaryAttributes', 'universe', universe)
            // verify required parameter 'secondaryAttribute' is not null or undefined
            assertParamExists('insertAllSecondaryAttributes', 'secondaryAttribute', secondaryAttribute)
            const localVarPath = `/{universe}/secondary-attributes`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secondaryAttribute, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {SecondaryAttribute} secondaryAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSecondaryAttribute: async (universe: string, id: string, secondaryAttribute: SecondaryAttribute, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('updateSecondaryAttribute', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSecondaryAttribute', 'id', id)
            // verify required parameter 'secondaryAttribute' is not null or undefined
            assertParamExists('updateSecondaryAttribute', 'secondaryAttribute', secondaryAttribute)
            const localVarPath = `/{universe}/secondary-attributes/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secondaryAttribute, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecondaryAttributeServiceApi - functional programming interface
 * @export
 */
export const SecondaryAttributeServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecondaryAttributeServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllSecondaryAttributes(universe: string, ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllSecondaryAttributes(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSecondaryAttribute(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSecondaryAttribute(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSecondaryAttributes(universe: string, ids?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SecondaryAttribute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSecondaryAttributes(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecondaryAttribute(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecondaryAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecondaryAttribute(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<SecondaryAttribute>} secondaryAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertAllSecondaryAttributes(universe: string, secondaryAttribute: Array<SecondaryAttribute>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SecondaryAttribute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertAllSecondaryAttributes(universe, secondaryAttribute, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {SecondaryAttribute} secondaryAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSecondaryAttribute(universe: string, id: string, secondaryAttribute: SecondaryAttribute, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecondaryAttribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSecondaryAttribute(universe, id, secondaryAttribute, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SecondaryAttributeServiceApi - factory interface
 * @export
 */
export const SecondaryAttributeServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecondaryAttributeServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllSecondaryAttributes(universe: string, ids: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllSecondaryAttributes(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecondaryAttribute(universe: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSecondaryAttribute(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSecondaryAttributes(universe: string, ids?: Array<string>, options?: any): AxiosPromise<Array<SecondaryAttribute>> {
            return localVarFp.getAllSecondaryAttributes(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecondaryAttribute(universe: string, id: string, options?: any): AxiosPromise<SecondaryAttribute> {
            return localVarFp.getSecondaryAttribute(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<SecondaryAttribute>} secondaryAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllSecondaryAttributes(universe: string, secondaryAttribute: Array<SecondaryAttribute>, options?: any): AxiosPromise<Array<SecondaryAttribute>> {
            return localVarFp.insertAllSecondaryAttributes(universe, secondaryAttribute, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {SecondaryAttribute} secondaryAttribute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSecondaryAttribute(universe: string, id: string, secondaryAttribute: SecondaryAttribute, options?: any): AxiosPromise<SecondaryAttribute> {
            return localVarFp.updateSecondaryAttribute(universe, id, secondaryAttribute, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecondaryAttributeServiceApi - object-oriented interface
 * @export
 * @class SecondaryAttributeServiceApi
 * @extends {BaseAPI}
 */
export class SecondaryAttributeServiceApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all objects with the given ids from the database
     * @param {string} universe 
     * @param {Array<string>} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecondaryAttributeServiceApi
     */
    public deleteAllSecondaryAttributes(universe: string, ids: Array<string>, options?: AxiosRequestConfig) {
        return SecondaryAttributeServiceApiFp(this.configuration).deleteAllSecondaryAttributes(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecondaryAttributeServiceApi
     */
    public deleteSecondaryAttribute(universe: string, id: string, options?: AxiosRequestConfig) {
        return SecondaryAttributeServiceApiFp(this.configuration).deleteSecondaryAttribute(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all objects from the database
     * @param {string} universe 
     * @param {Array<string>} [ids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecondaryAttributeServiceApi
     */
    public getAllSecondaryAttributes(universe: string, ids?: Array<string>, options?: AxiosRequestConfig) {
        return SecondaryAttributeServiceApiFp(this.configuration).getAllSecondaryAttributes(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecondaryAttributeServiceApi
     */
    public getSecondaryAttribute(universe: string, id: string, options?: AxiosRequestConfig) {
        return SecondaryAttributeServiceApiFp(this.configuration).getSecondaryAttribute(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inserts the objects into the database
     * @param {string} universe 
     * @param {Array<SecondaryAttribute>} secondaryAttribute 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecondaryAttributeServiceApi
     */
    public insertAllSecondaryAttributes(universe: string, secondaryAttribute: Array<SecondaryAttribute>, options?: AxiosRequestConfig) {
        return SecondaryAttributeServiceApiFp(this.configuration).insertAllSecondaryAttributes(universe, secondaryAttribute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an object in the database
     * @param {string} universe 
     * @param {string} id 
     * @param {SecondaryAttribute} secondaryAttribute 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecondaryAttributeServiceApi
     */
    public updateSecondaryAttribute(universe: string, id: string, secondaryAttribute: SecondaryAttribute, options?: AxiosRequestConfig) {
        return SecondaryAttributeServiceApiFp(this.configuration).updateSecondaryAttribute(universe, id, secondaryAttribute, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpellServiceApi - axios parameter creator
 * @export
 */
export const SpellServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllSpells: async (universe: string, ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteAllSpells', 'universe', universe)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteAllSpells', 'ids', ids)
            const localVarPath = `/api/{universe}/spells`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpell: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteSpell', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSpell', 'id', id)
            const localVarPath = `/api/{universe}/spells/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSpells: async (universe: string, ids?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getAllSpells', 'universe', universe)
            const localVarPath = `/api/{universe}/spells`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpell: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getSpell', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSpell', 'id', id)
            const localVarPath = `/api/{universe}/spells/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<Spell>} spell 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllSpells: async (universe: string, spell: Array<Spell>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('insertAllSpells', 'universe', universe)
            // verify required parameter 'spell' is not null or undefined
            assertParamExists('insertAllSpells', 'spell', spell)
            const localVarPath = `/api/{universe}/spells`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(spell, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {Spell} spell 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpell: async (universe: string, id: string, spell: Spell, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('updateSpell', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSpell', 'id', id)
            // verify required parameter 'spell' is not null or undefined
            assertParamExists('updateSpell', 'spell', spell)
            const localVarPath = `/api/{universe}/spells/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(spell, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpellServiceApi - functional programming interface
 * @export
 */
export const SpellServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpellServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllSpells(universe: string, ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllSpells(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpell(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSpell(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSpells(universe: string, ids?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Spell>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSpells(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpell(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Spell>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpell(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<Spell>} spell 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertAllSpells(universe: string, spell: Array<Spell>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Spell>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertAllSpells(universe, spell, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {Spell} spell 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSpell(universe: string, id: string, spell: Spell, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Spell>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSpell(universe, id, spell, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SpellServiceApi - factory interface
 * @export
 */
export const SpellServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpellServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllSpells(universe: string, ids: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllSpells(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpell(universe: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSpell(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSpells(universe: string, ids?: Array<string>, options?: any): AxiosPromise<Array<Spell>> {
            return localVarFp.getAllSpells(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpell(universe: string, id: string, options?: any): AxiosPromise<Spell> {
            return localVarFp.getSpell(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<Spell>} spell 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllSpells(universe: string, spell: Array<Spell>, options?: any): AxiosPromise<Array<Spell>> {
            return localVarFp.insertAllSpells(universe, spell, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {Spell} spell 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpell(universe: string, id: string, spell: Spell, options?: any): AxiosPromise<Spell> {
            return localVarFp.updateSpell(universe, id, spell, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpellServiceApi - object-oriented interface
 * @export
 * @class SpellServiceApi
 * @extends {BaseAPI}
 */
export class SpellServiceApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all objects with the given ids from the database
     * @param {string} universe 
     * @param {Array<string>} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellServiceApi
     */
    public deleteAllSpells(universe: string, ids: Array<string>, options?: AxiosRequestConfig) {
        return SpellServiceApiFp(this.configuration).deleteAllSpells(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellServiceApi
     */
    public deleteSpell(universe: string, id: string, options?: AxiosRequestConfig) {
        return SpellServiceApiFp(this.configuration).deleteSpell(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all objects from the database
     * @param {string} universe 
     * @param {Array<string>} [ids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellServiceApi
     */
    public getAllSpells(universe: string, ids?: Array<string>, options?: AxiosRequestConfig) {
        return SpellServiceApiFp(this.configuration).getAllSpells(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellServiceApi
     */
    public getSpell(universe: string, id: string, options?: AxiosRequestConfig) {
        return SpellServiceApiFp(this.configuration).getSpell(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inserts the objects into the database
     * @param {string} universe 
     * @param {Array<Spell>} spell 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellServiceApi
     */
    public insertAllSpells(universe: string, spell: Array<Spell>, options?: AxiosRequestConfig) {
        return SpellServiceApiFp(this.configuration).insertAllSpells(universe, spell, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an object in the database
     * @param {string} universe 
     * @param {string} id 
     * @param {Spell} spell 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpellServiceApi
     */
    public updateSpell(universe: string, id: string, spell: Spell, options?: AxiosRequestConfig) {
        return SpellServiceApiFp(this.configuration).updateSpell(universe, id, spell, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TalentServiceApi - axios parameter creator
 * @export
 */
export const TalentServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllTalents: async (universe: string, ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteAllTalents', 'universe', universe)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteAllTalents', 'ids', ids)
            const localVarPath = `/api/{universe}/talents`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTalent: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteTalent', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTalent', 'id', id)
            const localVarPath = `/api/{universe}/talents/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTalents: async (universe: string, ids?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getAllTalents', 'universe', universe)
            const localVarPath = `/api/{universe}/talents`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTalent: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getTalent', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTalent', 'id', id)
            const localVarPath = `/api/{universe}/talents/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<Talent>} talent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllTalents: async (universe: string, talent: Array<Talent>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('insertAllTalents', 'universe', universe)
            // verify required parameter 'talent' is not null or undefined
            assertParamExists('insertAllTalents', 'talent', talent)
            const localVarPath = `/api/{universe}/talents`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(talent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {Talent} talent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTalent: async (universe: string, id: string, talent: Talent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('updateTalent', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTalent', 'id', id)
            // verify required parameter 'talent' is not null or undefined
            assertParamExists('updateTalent', 'talent', talent)
            const localVarPath = `/api/{universe}/talents/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(talent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TalentServiceApi - functional programming interface
 * @export
 */
export const TalentServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TalentServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllTalents(universe: string, ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllTalents(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTalent(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTalent(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTalents(universe: string, ids?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Talent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTalents(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTalent(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Talent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTalent(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<Talent>} talent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertAllTalents(universe: string, talent: Array<Talent>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Talent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertAllTalents(universe, talent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {Talent} talent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTalent(universe: string, id: string, talent: Talent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Talent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTalent(universe, id, talent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TalentServiceApi - factory interface
 * @export
 */
export const TalentServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TalentServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllTalents(universe: string, ids: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllTalents(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTalent(universe: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTalent(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTalents(universe: string, ids?: Array<string>, options?: any): AxiosPromise<Array<Talent>> {
            return localVarFp.getAllTalents(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTalent(universe: string, id: string, options?: any): AxiosPromise<Talent> {
            return localVarFp.getTalent(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<Talent>} talent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllTalents(universe: string, talent: Array<Talent>, options?: any): AxiosPromise<Array<Talent>> {
            return localVarFp.insertAllTalents(universe, talent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {Talent} talent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTalent(universe: string, id: string, talent: Talent, options?: any): AxiosPromise<Talent> {
            return localVarFp.updateTalent(universe, id, talent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TalentServiceApi - object-oriented interface
 * @export
 * @class TalentServiceApi
 * @extends {BaseAPI}
 */
export class TalentServiceApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all objects with the given ids from the database
     * @param {string} universe 
     * @param {Array<string>} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TalentServiceApi
     */
    public deleteAllTalents(universe: string, ids: Array<string>, options?: AxiosRequestConfig) {
        return TalentServiceApiFp(this.configuration).deleteAllTalents(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TalentServiceApi
     */
    public deleteTalent(universe: string, id: string, options?: AxiosRequestConfig) {
        return TalentServiceApiFp(this.configuration).deleteTalent(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all objects from the database
     * @param {string} universe 
     * @param {Array<string>} [ids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TalentServiceApi
     */
    public getAllTalents(universe: string, ids?: Array<string>, options?: AxiosRequestConfig) {
        return TalentServiceApiFp(this.configuration).getAllTalents(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TalentServiceApi
     */
    public getTalent(universe: string, id: string, options?: AxiosRequestConfig) {
        return TalentServiceApiFp(this.configuration).getTalent(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inserts the objects into the database
     * @param {string} universe 
     * @param {Array<Talent>} talent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TalentServiceApi
     */
    public insertAllTalents(universe: string, talent: Array<Talent>, options?: AxiosRequestConfig) {
        return TalentServiceApiFp(this.configuration).insertAllTalents(universe, talent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an object in the database
     * @param {string} universe 
     * @param {string} id 
     * @param {Talent} talent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TalentServiceApi
     */
    public updateTalent(universe: string, id: string, talent: Talent, options?: AxiosRequestConfig) {
        return TalentServiceApiFp(this.configuration).updateTalent(universe, id, talent, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UniverseServiceApi - axios parameter creator
 * @export
 */
export const UniverseServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add the given access right to the given user
         * @param {string} universe 
         * @param {string} displayName 
         * @param {string} [accessPermission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUniversePermission: async (universe: string, displayName: string, accessPermission?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('addUniversePermission', 'universe', universe)
            // verify required parameter 'displayName' is not null or undefined
            assertParamExists('addUniversePermission', 'displayName', displayName)
            const localVarPath = `/api/universes/{universe}/permission`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (displayName !== undefined) {
                localVarQueryParameter['displayName'] = displayName;
            }

            if (accessPermission !== undefined) {
                localVarQueryParameter['accessPermission'] = accessPermission;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a universe
         * @param {Universe} universe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUniverse: async (universe: Universe, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('createUniverse', 'universe', universe)
            const localVarPath = `/api/universes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(universe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a universe
         * @param {string} universe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUniverse: async (universe: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteUniverse', 'universe', universe)
            const localVarPath = `/api/universes/{universe}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Universes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUniverses: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/universes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a universe
         * @param {string} universe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverse: async (universe: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getUniverse', 'universe', universe)
            const localVarPath = `/api/universes/{universe}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all access rights of the universe
         * @param {string} universe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversePermissions: async (universe: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getUniversePermissions', 'universe', universe)
            const localVarPath = `/api/universes/{universe}/permission`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes all access rights to the universe from the given user
         * @param {string} universe 
         * @param {string} displayName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUniversePermission: async (universe: string, displayName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('removeUniversePermission', 'universe', universe)
            // verify required parameter 'displayName' is not null or undefined
            assertParamExists('removeUniversePermission', 'displayName', displayName)
            const localVarPath = `/api/universes/{universe}/permission`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (displayName !== undefined) {
                localVarQueryParameter['displayName'] = displayName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a universe
         * @param {string} universe 
         * @param {Universe} universe2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUniverse: async (universe: string, universe2: Universe, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('updateUniverse', 'universe', universe)
            // verify required parameter 'universe2' is not null or undefined
            assertParamExists('updateUniverse', 'universe2', universe2)
            const localVarPath = `/api/universes/{universe}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(universe2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UniverseServiceApi - functional programming interface
 * @export
 */
export const UniverseServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UniverseServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add the given access right to the given user
         * @param {string} universe 
         * @param {string} displayName 
         * @param {string} [accessPermission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUniversePermission(universe: string, displayName: string, accessPermission?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUniversePermission(universe, displayName, accessPermission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a universe
         * @param {Universe} universe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUniverse(universe: Universe, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Universe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUniverse(universe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a universe
         * @param {string} universe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUniverse(universe: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUniverse(universe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all Universes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUniverses(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Universe>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUniverses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a universe
         * @param {string} universe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniverse(universe: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Universe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniverse(universe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all access rights of the universe
         * @param {string} universe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniversePermissions(universe: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserUniversePermissionDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniversePermissions(universe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Removes all access rights to the universe from the given user
         * @param {string} universe 
         * @param {string} displayName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUniversePermission(universe: string, displayName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUniversePermission(universe, displayName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a universe
         * @param {string} universe 
         * @param {Universe} universe2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUniverse(universe: string, universe2: Universe, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Universe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUniverse(universe, universe2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UniverseServiceApi - factory interface
 * @export
 */
export const UniverseServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UniverseServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Add the given access right to the given user
         * @param {string} universe 
         * @param {string} displayName 
         * @param {string} [accessPermission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUniversePermission(universe: string, displayName: string, accessPermission?: string, options?: any): AxiosPromise<void> {
            return localVarFp.addUniversePermission(universe, displayName, accessPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a universe
         * @param {Universe} universe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUniverse(universe: Universe, options?: any): AxiosPromise<Universe> {
            return localVarFp.createUniverse(universe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a universe
         * @param {string} universe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUniverse(universe: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUniverse(universe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Universes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUniverses(options?: any): AxiosPromise<Array<Universe>> {
            return localVarFp.getAllUniverses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a universe
         * @param {string} universe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniverse(universe: string, options?: any): AxiosPromise<Universe> {
            return localVarFp.getUniverse(universe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all access rights of the universe
         * @param {string} universe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversePermissions(universe: string, options?: any): AxiosPromise<Array<UserUniversePermissionDTO>> {
            return localVarFp.getUniversePermissions(universe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes all access rights to the universe from the given user
         * @param {string} universe 
         * @param {string} displayName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUniversePermission(universe: string, displayName: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeUniversePermission(universe, displayName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a universe
         * @param {string} universe 
         * @param {Universe} universe2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUniverse(universe: string, universe2: Universe, options?: any): AxiosPromise<Universe> {
            return localVarFp.updateUniverse(universe, universe2, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UniverseServiceApi - object-oriented interface
 * @export
 * @class UniverseServiceApi
 * @extends {BaseAPI}
 */
export class UniverseServiceApi extends BaseAPI {
    /**
     * 
     * @summary Add the given access right to the given user
     * @param {string} universe 
     * @param {string} displayName 
     * @param {string} [accessPermission] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseServiceApi
     */
    public addUniversePermission(universe: string, displayName: string, accessPermission?: string, options?: AxiosRequestConfig) {
        return UniverseServiceApiFp(this.configuration).addUniversePermission(universe, displayName, accessPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a universe
     * @param {Universe} universe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseServiceApi
     */
    public createUniverse(universe: Universe, options?: AxiosRequestConfig) {
        return UniverseServiceApiFp(this.configuration).createUniverse(universe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a universe
     * @param {string} universe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseServiceApi
     */
    public deleteUniverse(universe: string, options?: AxiosRequestConfig) {
        return UniverseServiceApiFp(this.configuration).deleteUniverse(universe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Universes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseServiceApi
     */
    public getAllUniverses(options?: AxiosRequestConfig) {
        return UniverseServiceApiFp(this.configuration).getAllUniverses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a universe
     * @param {string} universe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseServiceApi
     */
    public getUniverse(universe: string, options?: AxiosRequestConfig) {
        return UniverseServiceApiFp(this.configuration).getUniverse(universe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all access rights of the universe
     * @param {string} universe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseServiceApi
     */
    public getUniversePermissions(universe: string, options?: AxiosRequestConfig) {
        return UniverseServiceApiFp(this.configuration).getUniversePermissions(universe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes all access rights to the universe from the given user
     * @param {string} universe 
     * @param {string} displayName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseServiceApi
     */
    public removeUniversePermission(universe: string, displayName: string, options?: AxiosRequestConfig) {
        return UniverseServiceApiFp(this.configuration).removeUniversePermission(universe, displayName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a universe
     * @param {string} universe 
     * @param {Universe} universe2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniverseServiceApi
     */
    public updateUniverse(universe: string, universe2: Universe, options?: AxiosRequestConfig) {
        return UniverseServiceApiFp(this.configuration).updateUniverse(universe, universe2, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpgradeRecipeServiceApi - axios parameter creator
 * @export
 */
export const UpgradeRecipeServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllUpgradeRecipes: async (universe: string, ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteAllUpgradeRecipes', 'universe', universe)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteAllUpgradeRecipes', 'ids', ids)
            const localVarPath = `/api/{universe}/upgrade-recipes`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUpgradeRecipe: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteUpgradeRecipe', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUpgradeRecipe', 'id', id)
            const localVarPath = `/api/{universe}/upgrade-recipes/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUpgradeRecipes: async (universe: string, ids?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getAllUpgradeRecipes', 'universe', universe)
            const localVarPath = `/api/{universe}/upgrade-recipes`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpgradeRecipe: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getUpgradeRecipe', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUpgradeRecipe', 'id', id)
            const localVarPath = `/api/{universe}/upgrade-recipes/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<UpgradeRecipe>} upgradeRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllUpgradeRecipes: async (universe: string, upgradeRecipe: Array<UpgradeRecipe>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('insertAllUpgradeRecipes', 'universe', universe)
            // verify required parameter 'upgradeRecipe' is not null or undefined
            assertParamExists('insertAllUpgradeRecipes', 'upgradeRecipe', upgradeRecipe)
            const localVarPath = `/api/{universe}/upgrade-recipes`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upgradeRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {UpgradeRecipe} upgradeRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUpgradeRecipe: async (universe: string, id: string, upgradeRecipe: UpgradeRecipe, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('updateUpgradeRecipe', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUpgradeRecipe', 'id', id)
            // verify required parameter 'upgradeRecipe' is not null or undefined
            assertParamExists('updateUpgradeRecipe', 'upgradeRecipe', upgradeRecipe)
            const localVarPath = `/api/{universe}/upgrade-recipes/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upgradeRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpgradeRecipeServiceApi - functional programming interface
 * @export
 */
export const UpgradeRecipeServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpgradeRecipeServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllUpgradeRecipes(universe: string, ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllUpgradeRecipes(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUpgradeRecipe(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUpgradeRecipe(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUpgradeRecipes(universe: string, ids?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UpgradeRecipe>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUpgradeRecipes(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpgradeRecipe(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradeRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpgradeRecipe(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<UpgradeRecipe>} upgradeRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertAllUpgradeRecipes(universe: string, upgradeRecipe: Array<UpgradeRecipe>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UpgradeRecipe>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertAllUpgradeRecipes(universe, upgradeRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {UpgradeRecipe} upgradeRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUpgradeRecipe(universe: string, id: string, upgradeRecipe: UpgradeRecipe, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradeRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUpgradeRecipe(universe, id, upgradeRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpgradeRecipeServiceApi - factory interface
 * @export
 */
export const UpgradeRecipeServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpgradeRecipeServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllUpgradeRecipes(universe: string, ids: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllUpgradeRecipes(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUpgradeRecipe(universe: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUpgradeRecipe(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUpgradeRecipes(universe: string, ids?: Array<string>, options?: any): AxiosPromise<Array<UpgradeRecipe>> {
            return localVarFp.getAllUpgradeRecipes(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpgradeRecipe(universe: string, id: string, options?: any): AxiosPromise<UpgradeRecipe> {
            return localVarFp.getUpgradeRecipe(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<UpgradeRecipe>} upgradeRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllUpgradeRecipes(universe: string, upgradeRecipe: Array<UpgradeRecipe>, options?: any): AxiosPromise<Array<UpgradeRecipe>> {
            return localVarFp.insertAllUpgradeRecipes(universe, upgradeRecipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {UpgradeRecipe} upgradeRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUpgradeRecipe(universe: string, id: string, upgradeRecipe: UpgradeRecipe, options?: any): AxiosPromise<UpgradeRecipe> {
            return localVarFp.updateUpgradeRecipe(universe, id, upgradeRecipe, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpgradeRecipeServiceApi - object-oriented interface
 * @export
 * @class UpgradeRecipeServiceApi
 * @extends {BaseAPI}
 */
export class UpgradeRecipeServiceApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all objects with the given ids from the database
     * @param {string} universe 
     * @param {Array<string>} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradeRecipeServiceApi
     */
    public deleteAllUpgradeRecipes(universe: string, ids: Array<string>, options?: AxiosRequestConfig) {
        return UpgradeRecipeServiceApiFp(this.configuration).deleteAllUpgradeRecipes(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradeRecipeServiceApi
     */
    public deleteUpgradeRecipe(universe: string, id: string, options?: AxiosRequestConfig) {
        return UpgradeRecipeServiceApiFp(this.configuration).deleteUpgradeRecipe(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all objects from the database
     * @param {string} universe 
     * @param {Array<string>} [ids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradeRecipeServiceApi
     */
    public getAllUpgradeRecipes(universe: string, ids?: Array<string>, options?: AxiosRequestConfig) {
        return UpgradeRecipeServiceApiFp(this.configuration).getAllUpgradeRecipes(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradeRecipeServiceApi
     */
    public getUpgradeRecipe(universe: string, id: string, options?: AxiosRequestConfig) {
        return UpgradeRecipeServiceApiFp(this.configuration).getUpgradeRecipe(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inserts the objects into the database
     * @param {string} universe 
     * @param {Array<UpgradeRecipe>} upgradeRecipe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradeRecipeServiceApi
     */
    public insertAllUpgradeRecipes(universe: string, upgradeRecipe: Array<UpgradeRecipe>, options?: AxiosRequestConfig) {
        return UpgradeRecipeServiceApiFp(this.configuration).insertAllUpgradeRecipes(universe, upgradeRecipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an object in the database
     * @param {string} universe 
     * @param {string} id 
     * @param {UpgradeRecipe} upgradeRecipe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradeRecipeServiceApi
     */
    public updateUpgradeRecipe(universe: string, id: string, upgradeRecipe: UpgradeRecipe, options?: AxiosRequestConfig) {
        return UpgradeRecipeServiceApiFp(this.configuration).updateUpgradeRecipe(universe, id, upgradeRecipe, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpgradeServiceApi - axios parameter creator
 * @export
 */
export const UpgradeServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllUpgrades: async (universe: string, ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteAllUpgrades', 'universe', universe)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteAllUpgrades', 'ids', ids)
            const localVarPath = `/api/{universe}/upgrades`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUpgrade: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('deleteUpgrade', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUpgrade', 'id', id)
            const localVarPath = `/api/{universe}/upgrades/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUpgrades: async (universe: string, ids?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getAllUpgrades', 'universe', universe)
            const localVarPath = `/api/{universe}/upgrades`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpgrade: async (universe: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('getUpgrade', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUpgrade', 'id', id)
            const localVarPath = `/api/{universe}/upgrades/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<Upgrade>} upgrade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllUpgrades: async (universe: string, upgrade: Array<Upgrade>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('insertAllUpgrades', 'universe', universe)
            // verify required parameter 'upgrade' is not null or undefined
            assertParamExists('insertAllUpgrades', 'upgrade', upgrade)
            const localVarPath = `/api/{universe}/upgrades`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upgrade, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {Upgrade} upgrade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUpgrade: async (universe: string, id: string, upgrade: Upgrade, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'universe' is not null or undefined
            assertParamExists('updateUpgrade', 'universe', universe)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUpgrade', 'id', id)
            // verify required parameter 'upgrade' is not null or undefined
            assertParamExists('updateUpgrade', 'upgrade', upgrade)
            const localVarPath = `/api/{universe}/upgrades/{id}`
                .replace(`{${"universe"}}`, encodeURIComponent(String(universe)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upgrade, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpgradeServiceApi - functional programming interface
 * @export
 */
export const UpgradeServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpgradeServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllUpgrades(universe: string, ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllUpgrades(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUpgrade(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUpgrade(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUpgrades(universe: string, ids?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Upgrade>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUpgrades(universe, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpgrade(universe: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Upgrade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpgrade(universe, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<Upgrade>} upgrade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertAllUpgrades(universe: string, upgrade: Array<Upgrade>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Upgrade>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertAllUpgrades(universe, upgrade, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {Upgrade} upgrade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUpgrade(universe: string, id: string, upgrade: Upgrade, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Upgrade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUpgrade(universe, id, upgrade, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpgradeServiceApi - factory interface
 * @export
 */
export const UpgradeServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpgradeServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all objects with the given ids from the database
         * @param {string} universe 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllUpgrades(universe: string, ids: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllUpgrades(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUpgrade(universe: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUpgrade(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all objects from the database
         * @param {string} universe 
         * @param {Array<string>} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUpgrades(universe: string, ids?: Array<string>, options?: any): AxiosPromise<Array<Upgrade>> {
            return localVarFp.getAllUpgrades(universe, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an object from the database
         * @param {string} universe 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpgrade(universe: string, id: string, options?: any): AxiosPromise<Upgrade> {
            return localVarFp.getUpgrade(universe, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inserts the objects into the database
         * @param {string} universe 
         * @param {Array<Upgrade>} upgrade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertAllUpgrades(universe: string, upgrade: Array<Upgrade>, options?: any): AxiosPromise<Array<Upgrade>> {
            return localVarFp.insertAllUpgrades(universe, upgrade, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an object in the database
         * @param {string} universe 
         * @param {string} id 
         * @param {Upgrade} upgrade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUpgrade(universe: string, id: string, upgrade: Upgrade, options?: any): AxiosPromise<Upgrade> {
            return localVarFp.updateUpgrade(universe, id, upgrade, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpgradeServiceApi - object-oriented interface
 * @export
 * @class UpgradeServiceApi
 * @extends {BaseAPI}
 */
export class UpgradeServiceApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all objects with the given ids from the database
     * @param {string} universe 
     * @param {Array<string>} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradeServiceApi
     */
    public deleteAllUpgrades(universe: string, ids: Array<string>, options?: AxiosRequestConfig) {
        return UpgradeServiceApiFp(this.configuration).deleteAllUpgrades(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradeServiceApi
     */
    public deleteUpgrade(universe: string, id: string, options?: AxiosRequestConfig) {
        return UpgradeServiceApiFp(this.configuration).deleteUpgrade(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all objects from the database
     * @param {string} universe 
     * @param {Array<string>} [ids] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradeServiceApi
     */
    public getAllUpgrades(universe: string, ids?: Array<string>, options?: AxiosRequestConfig) {
        return UpgradeServiceApiFp(this.configuration).getAllUpgrades(universe, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an object from the database
     * @param {string} universe 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradeServiceApi
     */
    public getUpgrade(universe: string, id: string, options?: AxiosRequestConfig) {
        return UpgradeServiceApiFp(this.configuration).getUpgrade(universe, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inserts the objects into the database
     * @param {string} universe 
     * @param {Array<Upgrade>} upgrade 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradeServiceApi
     */
    public insertAllUpgrades(universe: string, upgrade: Array<Upgrade>, options?: AxiosRequestConfig) {
        return UpgradeServiceApiFp(this.configuration).insertAllUpgrades(universe, upgrade, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an object in the database
     * @param {string} universe 
     * @param {string} id 
     * @param {Upgrade} upgrade 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpgradeServiceApi
     */
    public updateUpgrade(universe: string, id: string, upgrade: Upgrade, options?: AxiosRequestConfig) {
        return UpgradeServiceApiFp(this.configuration).updateUpgrade(universe, id, upgrade, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserServiceApi - axios parameter creator
 * @export
 */
export const UserServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a user
         * @param {PnPUserCreation} pnPUserCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (pnPUserCreation: PnPUserCreation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pnPUserCreation' is not null or undefined
            assertParamExists('createUser', 'pnPUserCreation', pnPUserCreation)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pnPUserCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all display names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplayNames: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the permissions of a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissions: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getPermissions', 'username', username)
            const localVarPath = `/api/users/{username}/permissions`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUser', 'username', username)
            const localVarPath = `/api/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('removeUser', 'username', username)
            const localVarPath = `/api/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the password of a user
         * @param {string} username 
         * @param {PasswordChange} passwordChange 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword: async (username: string, passwordChange: PasswordChange, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updatePassword', 'username', username)
            // verify required parameter 'passwordChange' is not null or undefined
            assertParamExists('updatePassword', 'passwordChange', passwordChange)
            const localVarPath = `/api/users/{username}/password`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChange, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the permissions of a user
         * @param {string} username 
         * @param {Array<GetPermissions200ResponseInner>} getPermissions200ResponseInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermissions: async (username: string, getPermissions200ResponseInner: Array<GetPermissions200ResponseInner>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updatePermissions', 'username', username)
            // verify required parameter 'getPermissions200ResponseInner' is not null or undefined
            assertParamExists('updatePermissions', 'getPermissions200ResponseInner', getPermissions200ResponseInner)
            const localVarPath = `/api/users/{username}/permissions`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPermissions200ResponseInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user
         * @param {string} username 
         * @param {PnPUser} pnPUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (username: string, pnPUser: PnPUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateUser', 'username', username)
            // verify required parameter 'pnPUser' is not null or undefined
            assertParamExists('updateUser', 'pnPUser', pnPUser)
            const localVarPath = `/api/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pnPUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserServiceApi - functional programming interface
 * @export
 */
export const UserServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a user
         * @param {PnPUserCreation} pnPUserCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(pnPUserCreation: PnPUserCreation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(pnPUserCreation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all display names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisplayNames(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDisplayNames(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the permissions of a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissions(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPermissions200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissions(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PnPUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUser(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUser(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the password of a user
         * @param {string} username 
         * @param {PasswordChange} passwordChange 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePassword(username: string, passwordChange: PasswordChange, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(username, passwordChange, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the permissions of a user
         * @param {string} username 
         * @param {Array<GetPermissions200ResponseInner>} getPermissions200ResponseInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePermissions(username: string, getPermissions200ResponseInner: Array<GetPermissions200ResponseInner>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePermissions(username, getPermissions200ResponseInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates a user
         * @param {string} username 
         * @param {PnPUser} pnPUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(username: string, pnPUser: PnPUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(username, pnPUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserServiceApi - factory interface
 * @export
 */
export const UserServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserServiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a user
         * @param {PnPUserCreation} pnPUserCreation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(pnPUserCreation: PnPUserCreation, options?: any): AxiosPromise<void> {
            return localVarFp.createUser(pnPUserCreation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all display names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplayNames(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getDisplayNames(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the permissions of a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissions(username: string, options?: any): AxiosPromise<Array<GetPermissions200ResponseInner>> {
            return localVarFp.getPermissions(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(username: string, options?: any): AxiosPromise<PnPUser> {
            return localVarFp.getUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the password of a user
         * @param {string} username 
         * @param {PasswordChange} passwordChange 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword(username: string, passwordChange: PasswordChange, options?: any): AxiosPromise<void> {
            return localVarFp.updatePassword(username, passwordChange, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the permissions of a user
         * @param {string} username 
         * @param {Array<GetPermissions200ResponseInner>} getPermissions200ResponseInner 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermissions(username: string, getPermissions200ResponseInner: Array<GetPermissions200ResponseInner>, options?: any): AxiosPromise<void> {
            return localVarFp.updatePermissions(username, getPermissions200ResponseInner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a user
         * @param {string} username 
         * @param {PnPUser} pnPUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username: string, pnPUser: PnPUser, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(username, pnPUser, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserServiceApi - object-oriented interface
 * @export
 * @class UserServiceApi
 * @extends {BaseAPI}
 */
export class UserServiceApi extends BaseAPI {
    /**
     * 
     * @summary Create a user
     * @param {PnPUserCreation} pnPUserCreation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public createUser(pnPUserCreation: PnPUserCreation, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).createUser(pnPUserCreation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all display names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public getDisplayNames(options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).getDisplayNames(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the permissions of a user
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public getPermissions(username: string, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).getPermissions(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public getUser(username: string, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).getUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public removeUser(username: string, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).removeUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the password of a user
     * @param {string} username 
     * @param {PasswordChange} passwordChange 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public updatePassword(username: string, passwordChange: PasswordChange, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).updatePassword(username, passwordChange, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the permissions of a user
     * @param {string} username 
     * @param {Array<GetPermissions200ResponseInner>} getPermissions200ResponseInner 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public updatePermissions(username: string, getPermissions200ResponseInner: Array<GetPermissions200ResponseInner>, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).updatePermissions(username, getPermissions200ResponseInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a user
     * @param {string} username 
     * @param {PnPUser} pnPUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public updateUser(username: string, pnPUser: PnPUser, options?: AxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).updateUser(username, pnPUser, options).then((request) => request(this.axios, this.basePath));
    }
}


